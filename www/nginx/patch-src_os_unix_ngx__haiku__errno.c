egrep: warning: egrep is obsolescent; using grep -E
$NetBSD$

--- src/os/unix/ngx_haiku_errno.c.orig	2024-05-08 09:18:13.255590400 +0000
+++ src/os/unix/ngx_haiku_errno.c
@@ -0,0 +1,158 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+
+
+/*
+ * The strerror() messages are copied because:
+ *
+ * 1) strerror() and strerror_r() functions are not Async-Signal-Safe,
+ *    therefore, they cannot be used in signal handlers;
+ *
+ * 2) a direct sys_errlist[] array may be used instead of these functions,
+ *    but Linux linker warns about its usage:
+ *
+ * warning: `sys_errlist' is deprecated; use `strerror' or `strerror_r' instead
+ * warning: `sys_nerr' is deprecated; use `strerror' or `strerror_r' instead
+ *
+ *    causing false bug reports.
+ *
+ * We avoid using an indexed array because:
+ *
+ * 1) on Haiku at least, errors are declared as negative numbers.
+ *
+ * 2) even though there is a posix_error_mapper static library
+ *    on Haiku that works around this, the converted errors are
+ *    around 0x7fff0000 anyway.
+ *
+ * 3) the POSIX error codes are not all defined as B_POSIX_ERROR_BASE + n
+ *    on Haiku anyway.
+ */
+
+
+typedef struct {
+    int              error;
+    ngx_str_t        str;
+} ngx_errmap_t;
+
+static ngx_errmap_t   ngx_sys_errmap[] = {
+/*
+ * This list should be kept in sync with src/os/unix/ngx_errno.h and
+ * is generated by:
+
+awk 'BEGIN {d=0}
+/define NGX_/ {print "{ " $2 ", ngx_null_string },"}
+/#if .*_HAVE_/ {d=1;print $0}
+/#endif/ && d {d=0;print}
+' src/os/unix/ngx_errno.h | uniq
+
+ */
+{ NGX_EPERM, ngx_null_string },
+{ NGX_ENOENT, ngx_null_string },
+{ NGX_ENOPATH, ngx_null_string },
+{ NGX_ESRCH, ngx_null_string },
+{ NGX_EINTR, ngx_null_string },
+{ NGX_ECHILD, ngx_null_string },
+{ NGX_ENOMEM, ngx_null_string },
+{ NGX_EACCES, ngx_null_string },
+{ NGX_EBUSY, ngx_null_string },
+{ NGX_EEXIST, ngx_null_string },
+{ NGX_EXDEV, ngx_null_string },
+{ NGX_ENOTDIR, ngx_null_string },
+{ NGX_EISDIR, ngx_null_string },
+{ NGX_EINVAL, ngx_null_string },
+{ NGX_ENFILE, ngx_null_string },
+{ NGX_EMFILE, ngx_null_string },
+{ NGX_ENOSPC, ngx_null_string },
+{ NGX_EPIPE, ngx_null_string },
+{ NGX_EINPROGRESS, ngx_null_string },
+{ NGX_ENOPROTOOPT, ngx_null_string },
+{ NGX_EOPNOTSUPP, ngx_null_string },
+{ NGX_EADDRINUSE, ngx_null_string },
+{ NGX_ECONNABORTED, ngx_null_string },
+{ NGX_ECONNRESET, ngx_null_string },
+{ NGX_ENOTCONN, ngx_null_string },
+{ NGX_ETIMEDOUT, ngx_null_string },
+{ NGX_ECONNREFUSED, ngx_null_string },
+{ NGX_ENAMETOOLONG, ngx_null_string },
+{ NGX_ENETDOWN, ngx_null_string },
+{ NGX_ENETUNREACH, ngx_null_string },
+{ NGX_EHOSTDOWN, ngx_null_string },
+{ NGX_EHOSTUNREACH, ngx_null_string },
+{ NGX_ENOSYS, ngx_null_string },
+{ NGX_ECANCELED, ngx_null_string },
+{ NGX_EILSEQ, ngx_null_string },
+{ NGX_ENOMOREFILES, ngx_null_string },
+{ NGX_ELOOP, ngx_null_string },
+{ NGX_EBADF, ngx_null_string },
+#if (NGX_HAVE_OPENAT)
+{ NGX_EMLINK, ngx_null_string },
+#endif
+{ NGX_EAGAIN, ngx_null_string },
+{ 0, ngx_null_string }
+};
+static ngx_str_t      ngx_unknown_error = ngx_string("Unknown error");
+
+
+u_char *
+ngx_strerror(ngx_err_t err, u_char *errstr, size_t size)
+{
+    ngx_str_t  *msg = &ngx_unknown_error;
+    int i;
+
+    for (i = 0; ngx_sys_errmap[i].error != 0; i++) {
+        if (ngx_sys_errmap[i].error == err) {
+            msg = &ngx_sys_errmap[i].str;
+            break;
+        }
+    }
+
+    size = ngx_min(size, msg->len);
+
+    return ngx_cpymem(errstr, msg->data, size);
+}
+
+
+ngx_int_t
+ngx_strerror_init(void)
+{
+    char       *msg;
+    u_char     *p;
+    size_t      len;
+    ngx_err_t   err;
+    int i;
+
+    /*
+     * ngx_strerror() is not ready to work at this stage, therefore,
+     * malloc() is used and possible errors are logged using strerror().
+     */
+
+    for (i = 0; ngx_sys_errmap[i].error != 0; i++) {
+        msg = strerror(ngx_sys_errmap[i].error);
+        len = ngx_strlen(msg);
+
+        p = malloc(len);
+        if (p == NULL) {
+            goto failed;
+        }
+
+        ngx_memcpy(p, msg, len);
+        ngx_sys_errmap[i].str.len = len;
+        ngx_sys_errmap[i].str.data = p;
+    }
+
+    return NGX_OK;
+
+failed:
+
+    err = errno;
+    ngx_log_stderr(0, "malloc(%uz) failed (%d: %s)", len, err, strerror(err));
+
+    return NGX_ERROR;
+}
